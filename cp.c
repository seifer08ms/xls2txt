/*
 *	Copyright (C) 2005-2007 Jan Bobrowski <jb@wizard.ae.krakow.pl>
 *
 *	This program is free software; you can redistribute it and/or
 *	modify it under the terms of the GNU General Public License
 *	version 2 as published by the Free Software Foundation.
 */

#include "xls2txt.h"
#include <stdio.h>
#include <math.h>

static u8 uni2cs[0x2E0-0xA0];
static u8 *cs = 0;
static char badchar = '?';

static u8 fallbacks[] = " "
	" !cL\1Y|\4<\1-\6'\6>\3?AAAAAA\1CEEEEIIII\1NOOOOO\1OUUUUY\2aa"
	"aaaa\1ceeeeiiii\1nooooo\1ouuuuy\1yAaAaAaCcCcCcCcDdDdEeEeEeEe"
	"EeGgGgGgGgHhHhIiIiIiIiIi\2JjKk\1LlLlLlLlLlNnNnNnn\2OoOoOo\2R"
	"rRrRrSsSsSsSsTtTtTtUuUuUuUuUuUuWwYyYZzZzZzsbBBb\3Cc\2Dd\4FfG"
	"\3IKkl\2NnOOo\2Pp\5tTtTUu\1VYyZz\26AaIiOoUuUuUuUuUu\1AaAa\2G"
	"gGgKkOoOo\2j\3Gg\2NnAa\2OoAaAaEeEeIiIiOoOoRrRrUuUuSsTt\2HhNd"
	"\2ZzAaEeOoOoOoOoYy";

static u8 latin2[] = {160,
	0xA0,3,0xA4,2,0xA7,0xA8,4,0xAD,2,0xB0,3,0xB4,3,0xB8,8,0xC1,0xC2,
	1,0xC4,2,0xC7,1,0xC9,1,0xCB,1,0xCD,0xCE,4,0xD3,0xD4,1,0xD6,0xD7,
	2,0xDA,1,0xDC,0xDD,1,0xDF,1,0xE1,0xE2,1,0xE4,2,0xE7,1,0xE9,1,
	0xEB,1,0xED,0xEE,4,0xF3,0xF4,1,0xF6,0xF7,2,0xFA,1,0xFC,0xFD,4,
	0xC3,0xE3,0xA1,0xB1,0xC6,0xE6,4,0xC8,0xE8,0xCF,0xEF,0xD0,0xF0,6,
	0xCA,0xEA,0xCC,0xEC,29,0xC5,0xE5,2,0xA5,0xB5,2,0xA3,0xB3,0xD1,
	0xF1,2,0xD2,0xF2,7,0xD5,0xF5,2,0xC0,0xE0,2,0xD8,0xF8,0xA6,0xB6,2,
	0xAA,0xBA,0xA9,0xB9,0xDE,0xFE,0xAB,0xBB,8,0xD9,0xF9,0xDB,0xFB,7,
	0xAC,0xBC,0xAF,0xBF,0xAE,0xBE,159,159,10,0xB7,16,0xA2,0xFF,1,
	0xB2,1,0xBD,0
};

int find_charset(char *name)
{
	const char names[] = "utf8asc\0iso1iso2";
	int l, p;
	l = strlen(name);
	if(l<3 || l>4) return -1;
	for(p=0; names[p]; p+=4)
		if(memcmp(names+p, name, 4)==0)
			return p>>2;
	return -1;
}

static void expand(u8 *s)
{
	u8 *d = uni2cs;
	u8 m = *s++;
	do {
		u8 c = *s++;
		if(c<m) d += c;
		else if(d>=endof(uni2cs)) break;
		else *d++ = c;
	} while(*s);
}

void set_charset(int n)
{
	cs = 0;
	if(n==0) // utf8
		return;

//	memset(uni2cs, 0, sizeof uni2cs);
	expand(fallbacks);

	switch(n) {
		int u;
	case 1: // ascii
		break;
	case 2: // latin 1
		for(u=0x00A0; u<0x0100; u++)
			uni2cs[u-0xA0] = u;
		break;
	case 3: // latin 2
		expand(latin2);
		break;
	}
	cs = uni2cs;
}

static void print_uni_char(u16 u)
{
	unsigned v = u;
	if(v<0x00A0) {
		if(v<0x20 || v>=0x7F)
			v = v==10 ? ' ' : badchar;
	} else if(cs) {
		v -= 0xA0;
		if(v >= sizeof uni2cs || !(v = cs[v]))
			v = badchar;
	} else {
		v = v>>6 | 0xC0;
		if(u >= 0x800) {
			putchar(u>>12 | 0xE0);
			v = v&077 | 0x80;
		}
		putchar(v);
		v = u&077 | 0x80;
	}
	putchar(v);
}

u8 *print_uni(u8 *p, int l, u8 f)
{
	if(f&1)
		while(--l >= 0) {
			print_uni_char(g16(p));
			p += 2;
		}
	else
		while(--l >= 0)
			print_uni_char(*p++);
	return p;
}

// codepage

static u16 *cp = 0;

static u16 cp1250[128] = {
	0,0,0x201A,0,0x201E,0x2026,0x2020,0x2021,0,0x2030,0x0160,0x2039,
	0x015A,0x0164,0x017D,0x0179,0,0x2018,0x2019,0x201C,0x201D,0x2022,
	0x2013,0x2014,0,0x2122,0x0161,0x203A,0x015B,0x0165,0x017E,0x017A,
	0x00A0,0x02C7,0x02D8,0x0141,0x00A4,0x0104,0x00A6,0x00A7,0x00A8,
	0x00A9,0x015E,0x00AB,0x00AC,0x00AD,0x00AE,0x017B,0x00B0,0x00B1,
	0x02DB,0x0142,0x00B4,0x00B5,0x00B6,0x00B7,0x00B8,0x0105,0x015F,
	0x00BB,0x013D,0x02DD,0x013E,0x017C,0,0x00C1,0x00C2,0x0102,0x00C4,
	0x0139,0x0106,0x00C7,0x010C,0x00C9,0x0118,0x00CB,0x011A,0x00CD,
	0x00CE,0x010E,0x0110,0x0143,0x0147,0x00D3,0x00D4,0x0150,0x00D6,
	0x00D7,0x0158,0x016E,0x00DA,0x0170,0x00DC,0x00DD,0x0162,0x00DF,
	0x0155,0x00E1,0x00E2,0x0103,0x00E4,0x013A,0x0107,0x00E7,0x010D,
	0x00E9,0x0119,0x00EB,0x011B,0x00ED,0x00EE,0x010F,0x0111,0x0144,
	0x0148,0x00F3,0x00F4,0x0151,0x00F6,0x00F7,0x0159,0x016F,0x00FA,
	0x0171,0x00FC,0x00FD,0x0163,0x02D9,
};

static u16 cp1252[128] = {
	0x20AC,0x0081,0x201A,0x0192,0x201E,0x2026,0x2020,0x2021,0x02C6,
	0x2030,0x0160,0x2039,0x0152,0x008D,0x017D,0x008F,0x0090,0x2018,
	0x2019,0x201C,0x201D,0x2022,0x2013,0x2014,0x02DC,0x2122,0x0161,
	0x203A,0x0153,0x009D,0x017E,0x0178,0x00A0,0x00A1,0x00A2,0x00A3,
	0x00A4,0x00A5,0x00A6,0x00A7,0x00A8,0x00A9,0x00AA,0x00AB,0x00AC,
	0x00AD,0x00AE,0x00AF,0x00B0,0x00B1,0x00B2,0x00B3,0x00B4,0x00B5,
	0x00B6,0x00B7,0x00B8,0x00B9,0x00BA,0x00BB,0x00BC,0x00BD,0x00BE,
	0x00BF,0x00C0,0x00C1,0x00C2,0x00C3,0x00C4,0x00C5,0x00C6,0x00C7,
	0x00C8,0x00C9,0x00CA,0x00CB,0x00CC,0x00CD,0x00CE,0x00CF,0x00D0,
	0x00D1,0x00D2,0x00D3,0x00D4,0x00D5,0x00D6,0x00D7,0x00D8,0x00D9,
	0x00DA,0x00DB,0x00DC,0x00DD,0x00DE,0x00DF,0x00E0,0x00E1,0x00E2,
	0x00E3,0x00E4,0x00E5,0x00E6,0x00E7,0x00E8,0x00E9,0x00EA,0x00EB,
	0x00EC,0x00ED,0x00EE,0x00EF,0x00F0,0x00F1,0x00F2,0x00F3,0x00F4,
	0x00F5,0x00F6,0x00F7,0x00F8,0x00F9,0x00FA,0x00FB,0x00FC,0x00FD,
	0x00FE,0x00FF,
};

static u16 cp1200[128]; // not initialized

void set_codepage(int n)
{
	if(n==1200) {
		int i;
		for(i=0x80; i<=0xFF; i++) cp1200[i-0x80] = i;
		cp = cp1200;
	} else if(n==1250 || n==0x8001) cp = cp1250;
	else if(n==1252) cp = cp1252;
	else if(n!=0x16F) warnx("%d: Codepage not supported", n);
}

u8 *print_cp_str(u8 *p, int l)
{
	u8 *e = p + l;
	while(p<e) {
		u8 c = *p++;
		if(c<=0x7F) {
			if(c==0x7F) goto badchar;
			if(c<0x20) {
				if(c!=10) goto badchar;
				c=' ';
			}
		} else if(cp) {
			print_uni_char(cp[c-0x80]);
			continue;
		} else
badchar:
			c = badchar;
		putchar(c);
	}
	return p;
}
